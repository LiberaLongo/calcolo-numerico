# -*- coding: utf-8 -*-
"""03_python_NumPy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BVeWPggKvYXpBbQl4vn6Ka91F7cVoCt7

# **Tips on Numpy**

NumPy is a library for the Python programming language whose main objects are large and multi-dimensional arrays, which includes a large collection of high-level mathematical functions to operate on these arrays.
"""

import numpy as np


"""### **DEFINING ARRAYS**"""

A=np.array([[1,2,3],[4,5,6],[7 , 8 ,9]] ) #a list becomes an array #we will see some exemples for which the choice of the dtype may affect the result
B=np.array([1,2,3,4]) #a tuple becomes an array
C= np.arange(9)
D=np.array([[1, 2,3]])
E=np.reshape(C, (9,1))
F=np.reshape(A, (9,1))
print(A,'\n')
print(B,'\n')
print(C,'\n')
print(E,'\n')


print(A.size)

print('shape A:',A.shape)
print('shape B:',B.shape)
print('shape C:',C.shape)
print('shape D:',D.shape)
print('shape E',E.shape,'\n')

print('ndim A:',A.ndim)
print('ndim B:',B.ndim)
print('ndim C:',C.ndim)
print('ndim D:',D.ndim)
print('ndim E:',E.ndim,'\n')

print(A.dtype)
print(B.dtype)


M=np.array([A,A,A,A])
print(M.shape)
print(M ,'\n')

N=np.zeros((2,2))
print('N:\n', N,'\n')

print('np.diag: \n',np.diag(B),'\n')

print('np.zeros:\n',np.zeros((3,3)),'\n')

print('np.ones:\n',np.ones((3,3)),'\n')

print('np.eye:\n',np.eye(3),'\n')

#Equidistant
D=np.linspace(0,10,num=4)
print(D)

#From a callable function
f = lambda m,n: n + 10*m
E = np.fromfunction(f, (3,3), dtype=np.float64)
print(E)

"""### **ARITMETIC OPERATION**

Let's work with numpy arrays.
"""

x = np.linspace(-4, 4, 3)
print(x,'\n')
print(np.outer(x, x),'\n')

# help(np.outer)

x = np.ones((5))
y = np.linspace(1,5,5)
print(x.shape)
print(y.shape,'\n')
print(x)
print(y,'\n')

z= x+y
print('x+y: ',z,'\n')

z= x-y
print('x-y:',z,'\n')

z= x*y
print('x*y: ',z,'\n')

z= x/y
print('x\y:',z,'\n')

z= np.exp(x)
print('np.exp(x):', z,'\n')

z= np.sqrt(y)
print('np.sqrt(y):',z,'\n')

z= np.dot(x,y)
print('np.dot(x,y): ',z,'\n')

print(type(z))

x = np.ones((5,1))
y = np.linspace(1,5,5)
y = y.reshape((1,5))
print(x.shape)
print(y.shape)
print(x)
print(y)

z= x+y
print(z)

z= x-y
print(z)

z= x*y
print(z)

z= x/y
print(z)

z= np.exp(x)
print(z)

z= np.sqrt(y)
print(z)

print(z.shape)

z= np.dot(y,x)
print(z)

help(np.dot)

"""### **MATRIX-VECTOR MOLTIPLICATION**"""

A=[[1,2,3],[4,5,6],[7,8,9]]
A=np.array(A)
print(A)
print(A.shape)

v=np.ones((A.shape[1],1))
print(v)
print(v.shape,'\n')

s= A@v
print('A@v \n',s)

result=np.matmul(A,v)
print('np.matmul \n',result)
print(result.shape)


result= A*v #watch out! This is not matrix-vector moltiplication
print(result)

x = np.ones((5,1))
y = np.linspace(1,5,5)
y = y.reshape((1,5))

print(np.dot(y,x))
print(np.matmul(y,x))

"""### **ARRAY MANIPULATION**"""

A=np.random.randint(5,size=(2,2))
print('A:\n',A,'\n')

B=np.transpose(A)
C=A.T
print('B:\n',B,'\n')
print('A==B:\n',A==B,'\n')
print('C==B:\n',C==B,'\n')

print('np.linalg.matrix_rank(A):\n',np.linalg.matrix_rank(A),'\n')
C=np.linalg.inv(A)
print(np.matmul(C,A),'\n')
print(C*A,'\n')
print(C@A)

"""### **AGGREGATION OF ARRAYS AND CONDITIONAL EXPRESSION**"""

t=np.sum(A)
print(t,'\n')

t = np.sum(A, axis=0)
print(t,'\n')

t = np.sum(A, axis=1)
print(t,'\n')

t=np.mean(A)
print(t,'\n')

t=np.std(A)
print(t,'\n')

t=np.prod(A)
print(t,'\n')

x=np.linspace(-10,10,5)
print(x,'\n')
print(x<0,'\n')

s=np.array(x[np.nonzero(x<0)])
print(s,'\n')

help(np.nonzero)

"""**FOR inside an array**"""

a=np.zeros((1,10))
print(a)
print(np.size(a))

for i in range(np.size(a)):
  a[0,i]=1

print(a)

a=np.arange(9)
print('a: \n',a,'\n')

a=np.reshape(a,(3,3))
print('a: \n',a,'\n')

t = a[:,2]
print('a[:,2]: \n',t,'\n')

t = a[1,:]
print('a[1,:]: \n',t,'\n')

t = a[1:3,1:]
print('a[1:3,1:]: \n',t,'\n')

"""# Matplotlib

"""

import matplotlib.pyplot as plt

x = np.linspace(-10,10, num=200)
y = np.exp(x)

#plt.plot(x,y,color='red', linestyle='--')
plt.plot(x,y,color='blue', linestyle='--')

plt.legend(['exp'])

plt.show()

